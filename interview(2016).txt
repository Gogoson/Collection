1、ES6新特性
   1) let:声明的变量具有块级作用域，避免污染作用域外的同名变量，避免循环变量泄露成为全局变量
   2) const:声明的是常量,如果常量被进行赋值操作，则报错，一般用在引入第三方库时，作为全局使用。
      例如：const jQuery = require('jQuery');
   3) class, extends, super的引入改写了ES5中使用原型链来实现继承的方式，变得更加简洁明了
      例如：
            class Animal {
                 constructor(){
                     this.type = 'animal';
                 }
                 says(say){
                     console.log(this.type + ' says ' + say);
                 }
            }

            let animal = new Animal();
            animal.says('hello') ;//animal says hello

            class Cat extends Animal {
                 constructor(){
                     super(); //如果不调用super方法，子类继承不了父类的this对象
                     this.type = 'cat';
                 }
            }

            let cat = new Cat();
            cat.says('hello'); //cat says hello   
   4)arrow function 箭头函数，简洁是第一特性，第二特性是解决this指向问题，在ES5中调用对象里的方法时，
     经常要注意this的指向问题，在箭头函数中它指向的是定义时的上下文对象，而不是运行时的上下文对象。
     例如：
          function(i){ return i + 1; } //ES5
          (i) => i + 1 //ES6  

   5)template string 模板字符串，用反引号(`)来标识起始，用${}来引用变量，空格和缩进都会被保留在输出之中
     例如：
          $("#result").append(`
            There are <b>${basket.count}</b> items
            in your basket, <em>${basket.onSale}</em>
            are on sale!
           `);
   6)destructuring 解构
     数组解构：
     var [a, b, c=3] = [1, 2];  // a = 1; b = 2; c = 3;
     数组解构一般用于赋值，特别是调用函数返回多个数值要分别赋值给不同的变量。
     对象解构：
     let dog = {type: 'animal', many: 2};
     let { type, many} = dog;  //type='animal'; many=2;
     对象解构一般用于定义函数的参数，良好的API参数一般都是用一个对象来进行传递，不用记住参数的顺序

   7)default 函数参数默认值
     function animal(type = 'cat'){
        console.log(type)
     }
     animal();
    8)rest  ...a ：把剩下的参数归集到a中，它是个数组，你懂的啦
      例如：
      'use strict';  
       function func(a,b,...args){  
           console.log(args);
       }  
       func(1,2,3,4); //[3,4]  

2、css3
   box-shadow: X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色 投影方式(可以设置inset为向内投影)
   text-shadow:X轴偏移量 Y轴偏移量 阴影模糊半径 阴影颜色
   1）以上两个属性可以用于IE9+，属性值中阴影模糊半径不能为负值，为负值则没有任何shadow效果。
   2）以上两个属性都可以设置多个shadow效果，以逗号隔开即可。
   3）box-shadow属性可以产生跟margin类似的效果，但是box-shadow不影响盒子模型。
   4）box-shadow直接在img元素上使用inset是没有任何效果的，可以利用img的父层容器或者父容器的:after伪元素实现
   5）当给同一个元素使用多个阴影属性时，需要注意它的顺序，最先写的阴影将显示在最顶层。
   6）整个层级：边框>内阴影>背景图片>背景颜色>外阴影

   border-radius:10px / 20px 
   表示圆角水平半径是10px,垂直半径是20px。
   border-radius:10px 20px 
   表示border-top-left-radius 和 border-bottom-right-radius是10px,其余角是20px,跟border一样遵循TRBL原则。

   background:-webkit-linear-gradient(top,#FFF 50%,#999,green ,#000);
   top表示从上到下渐变颜色，#FFF是起始颜色，#000是终止颜色，中间的颜色可以选，50%表示#FFF占据背景色一般然后在进行渐变

3、只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。   

4、CMD
   1)在 CMD 规范中，一个模块就是一个文件，define是一个全局函数，用来定义模块。
   2)define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。
   3)factory 为函数时，表示是模块的构造方法，默认会传入三个参数：require、exports 和 module
     define(function(require, exports, module) {
           // 模块代码
     });
   4)define(id?, deps?, factory)
     注意：带 id 和 deps 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。
   5)模块 factory 构造方法的第一个参数必须命名为 require
   6)require 的参数值必须是字符串直接量
   7)require.async 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选
     define(function(require, exports, module) {
        // 异步加载一个模块，在加载完成时，执行回调
        require.async('./b', function(b) {
        b.doSomething();
      });

       // 异步加载多个模块，在加载完成时，执行回调
       require.async(['./c', './d'], function(c, d) {
       c.doSomething();
       d.doSomething();
      });

    });
    require.async 一般用来加载可延迟异步加载的模块。
   8)传给 factory 构造方法的 exports 参数是 module.exports 对象的一个引用
     向外提供接口可以用 module.exports = {} 或者 exports.XXX = XXX 或者 return {}
     不能这样用：
     exports = {} 、module.exports = function(){}、return function(){}
   9)对 module.exports 的赋值需要同步执行，不能放在回调函数里
   10)exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变
     module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口
  11)用seajs.config进行配置:
      seajs.config({
        // 设置路径，方便跨目录调用
        paths: {
          'arale': 'https://a.alipayobjects.com/arale',
          'jquery': 'https://a.alipayobjects.com/jquery'
        },
        
        // 设置别名，方便调用
        alias: {
          'class': 'arale/class/1.0.0/class',
          'jquery': 'jquery/jquery/1.10.1/jquery'
        }
      });  
   12)seajs.use用来在页面中加载一个或多个模块: 
      // 加载一个模块
      seajs.use('./a');

      // 加载一个模块，在加载完成时，执行回调
      seajs.use('./a', function(a) {
        a.doSomething();
      });

      // 加载多个模块，在加载完成时，执行回调
      seajs.use(['./a', './b'], function(a, b) {
        a.doSomething();
        b.doSomething();
      });     
5、AMD && requireJs
   AMD规范只定义了一个函数 define 。
   define(id?, dependencies?, factory);
   require()函数接受两个参数。第一个参数是一个数组，第二个参数是一个回调函数。
   require.config()使用paths指定路径，可以设置baseUrl，这是全局的，后面如果加载的模块没有指定路径，
   默认取baseUrl。
   shim用来加载非规范的模块。
   AMD是依赖前置，所有的依赖全部加载完了，才会执行回调
   // math.js
　　define(function (){
　　　　var add = function (x,y){
　　　　　　return x+y;
　　　　};
　　　　return {
　　　　　　add: add
　　　　};
　　});

   require(['math'], function (math){
　　　　alert(math.add(1,1));
　　});
    
    AMD也可以写出简洁的commonJS的形式，但是本质上，所有依赖还是会前置执行了，本质还是AMD。
6、兼容问题
   1）IE8不支持字符串的trim、indexOf函数
   2）IE8基本上不支持CSS3属性border-radius、box-shadow、text-shadow
   3）IE8不支持这些CSS3选择器：
      :last-child 、:nth-child(n)、:first-of-type、:last-of-type
   4）color: green\0;只有IE8才能识别。
   5）opacity属性，在IE8要用alpha通道才能实现，例如
      filter: alpha(opacity=20);相当于 opacity:0.2
   6）IE hack和IE条件注释
   7）ie8css3圆角的实现使用PIE.htc，behavior: url(../../../public/css/PIE.htc);
      注意：这个路径是html相对于PIE的路径
7、招商信诺面试：
   闭包用在哪里
   promise是怎样的
   移动端手机键盘事件能获取吗
   移动端输入框跟随键盘变动怎么实现
   H5有哪些新特性，用在哪里
   sass和less的区别是什么
   移动端你会怎么选择js框架
   浏览器兼容了解怎样
   手机浏览器兼容了解哪些
   移动端自适应怎么做
   用过angular框架吗
   用过哪些大的框架
   css的权重
   jQuery怎么选择一个文本内容
   requirejs和seajs有什么区别
   性能优化有哪些可以做的

8、sass和less的区别
   1）两者都是CSS的预处理器，方便我们编写css
   2）Sass 和 Less 都使用的是标准的 CSS 语法
   3）Sass 的变量必须是 $ 开始， Less 的变量名使用 @ 符号开始
   4）嵌套使得父子节点关系一目了然，嵌套语法都一样
   5）对于混合（mixin）（类似函数功能）
      sass语法是
		@mixin border-radius($values) {
		  -webkit-border-radius: $values;
		     -moz-border-radius: $values;
		          border-radius: $values;
		}
		  
		div {
		  @ include border-radius(10px);
		}
      less语法是
		.border-radius(@values) {
		  -webkit-border-radius: @values;
		     -moz-border-radius: @values;
		          border-radius: @values;
		}
		  
		div {
		  .border-radius(10px);
		}
   6）继承
      sass用.selector {@extend .block;}，sass会形成分组
      less用.selector {.block;}，less直接把继承的样式插入代码中
   7）导入
      导入文件中定义的混入、变量等信息也将会被引入到主样式文件中，因此需要避免它们互相冲突。
      @ import "reset.css";
   8）Sass 有两种语法
      以.scss 扩展名，能理解大多数 CSS hacks 以及浏览器专属语法，例如IE 古老的 filter 语法。
      以.sass 扩展名，不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，而且也不使用分号，
      而是用换行符来分隔属性
    9）less的混合和继承有点类似，不同的是混合用的是自定义的名字，还可以传参数，继承则用的是选择器，没有参数可选
    10）都带有函数，比如颜色函数lighten(@base, 25%)

9、性能优化
   js:
   1）动画使用绝对定位，避免重排和重绘
   2）使用事件委托来减少事件处理器的数量
   3）能使用原始的API时尽量使用，比如maths函数，querySelectorAll()
   4）缓存集合和长度
   5）批量修改样式，降低重排和重绘的次数
   6）避免使用eval()，因为会带来双重求值的性能消耗
   7）尽量使用直接量创建对象和数组，直观，代码量少，创建和初始化要快
   8）避免使用for in循环，除非你要遍历一个属性数量未知的对象，因为for in 操作会同时搜索实例或原型属性。
   9）缓存循环体长度，倒叙循环，把减法操作放在控制条件中
   10）if else条件尽量把最可能出现的条件放在首位

   css:
   1）避免层级或过度限制的CSS
   2）避免后代选择器
   3）避免适用通配符
   4）避免甚至不要使用CSS表达式

   其他：
   1）避免重定向
   2）减少http请求，合并脚本和样式文件，内联图片，合并多张小图
   3）使用外部Javascirpt和CSS文件，经常访问的页面会有缓存，但是不常访问的页面就用内联样式
   4）前端资源添加过期日期，expires或者cache-control报文头
   5）配置Etag文件实体标签，避免下载全部的文件，返回304文件头就可以了
   6）样式文件放头部，脚本放在底部，对显示无特别重要的脚本，可以延迟加载
   7）提前加载
   8）混动加载或者延迟加载

10、HttpOnly 与 secure
    1）如果在Cookie中设置了"HttpOnly"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，
    这样能有效的防止XSS攻击。
    2）secure属性设置为true时，只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，防止信息在传递
    的过程中被监听捕获后信息泄漏。
    3）cookie默认的有效期只能持续在浏览器的回话期间（即是说，默认的有效期与浏览器进程挂钩而不是浏览器单个窗口），
    一旦用户关闭浏览器，cookie保存的数据就丢失了。